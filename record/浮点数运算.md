# 浮点数运算

## 浮点数的组成

1. 根据IEEE-754标准,浮点数由三部分组成,分别是符号位(S),指数位(E)以及尾数位(M)。

            S          E                     M
         ______ _______________ ____________________________
        |______|_______________|____________________________|
 
- 16位浮点数(Half)  : S = 1 , E = 5  , M = 10
- 32位浮点数(float) : S = 1 , E = 8  , M = 23
- 64位浮点数(double): S = 1 , E = 11 , M = 52
- 注: 以上均表示位宽。

1. 阶码。浮点数的阶码为: 2^(E-1) - 1。指数部分的实际取值为: -(2^(E-1)-2) ~ 2^(E-1)-1。
   
阶码的好处: 使用阶码就可以用长度为E个比特的无符号整数来表示所有的指数取值。不使用阶码的话,指数部分就是无符号数,一些小数就无法表示了。
   
3. 浮点数分为规格化数与非规格化数,除此以外还有一些特殊数值。

规格化数:   尾数位首位为1,浮点数值为: n = (-1)^S * |1.M| * 2^(E - 阶码)

非规格化数: 指数位为全0,尾数位首位为0,浮点数值为: n = (-1)^S * |0.M| * 2^-(阶码 - 1)

特殊数值: E = 255, M = 0 时表示无穷大。
         E = 255, M != 0时表示不合法数值。

[浮点数组成](https://zhuanlan.zhihu.com/p/146173358)
[规格数、非规格数与特殊数值](https://zhuanlan.zhihu.com/p/343049681)

## 浮点数加法

1. 对阶

- 两个浮点数在做加法之前,要先保证指数相等。
- 对阶原则为小阶对大阶,这样损失的精度更小,如果大阶对小阶,尾数的数值部分的高位需移出,损失的精度较大。
- 指数相等之后需要对尾数进行右移操作,保证对阶前后数值大小不变。右移的位数等于两浮点数指数的差。当差大于尾数的位数时,右移的位数等于尾数的位数。

2. 尾数运算

- 采用定点数加法的方式。
- 注意符号位,如果符号位不一致就是减法。

3. 结果规格化

- 尾数相加减后,可能会出现非规格化的形式,为此必须进行规格化操作。
- 右规操作: 查看尾数相加后是否产生进位,如有进位,尾数右移1位,阶码加1。
- 左规操作: 尾数没有产生进位,将尾数左移,同时阶码减去左移的尾数,一直到尾数为1.M的形式。

4. 舍入处理

- 对阶与规格化的过程都会产生误差,可以将移出去的位保存下来,之后进行规格化处理。
- 就近舍入: 多余位小于等于011...1111,直接舍去。
           多余位大于等于100...0000,尾数最低位为1则加1,若为0,则舍去。
- 朝正无穷舍入: 对正数来说,多余位不全为0,尾数最低位进1;对负数来说,直接舍去。
- 朝负无穷舍入: 对负数来说,多余位不全为0,尾数最低位进1;对正数来说,直接舍去。
- 朝0舍入: 不管多余位是多少,直接全部舍去。

5. 遇到问题
   
- 未考虑输入非规格化数与特殊数值的情况。

6. 解决方案

- 计算A + B时,当B为非规格化数时,B可视为0,计算结果为A。
- 当输入数值有一个为正无穷大时,输出为7c00。输入数值为负无穷大时,输出为fc00。
  
[浮点数加法](https://www.cnblogs.com/yilang/p/11277201.html)

## 浮点数乘法

1. 阶码相加。

2. 尾数相乘,采用定点数乘法。

3. 舍入处理: 相乘之后根据后(M-1)位采用就近舍入的方式。

4. 左规操作: 浮点数乘法是不存在右规的。

5. 遇到问题

- 未考虑输入非规格化数以及特殊数值的情况
- 未考虑两数相乘结果为非规格化数的情况

6. 解决方案

- 当输入的两个数值中出现非规格数时结果为0
- 当输入的两个数值中出现无穷大时,正无穷大结果为7c00,负无穷大结果为fc00
- 对尾数相乘的结果进行判决,如果结果为非规格数则为0,若为无穷大,结果为7c00或fc00

# 浮点数除法运算

1. 阶码相减。

2. 尾数相除,采用定点数除法。

3. 舍入处理: 相乘之后根据后(M-1)位采用就近舍入的方式。

4. 左规操作: 浮点数乘法是不存在右规的。

5. 遇到问题







## 算法理解

1. 阶码相减: 按照定点整数的加减法运算方法对两个浮点数的阶码进行加减运算。
2. 尾数相除: 按照定点小数的阵列除法运算方法对两个浮点数的尾数进行除法运算。为了保证被除数尾数的绝对值一定小于除数尾数的绝对值。若被除数尾数的绝对值大于除数尾数的绝对值，需对被除数进行调整，即被除数的尾数每右移一位，阶码加1，直到被除数尾数的绝对值小于除数尾数的绝对值。
3. 结果规格化并进行舍入处理: 浮点数除法运算结果的规格化和舍入处理与浮点数加减运算结果的规格化和舍入处理方法相同。并且在浮点数除法运算的结果中，由于商的绝对值一定小于1，因此在浮点除法运算结果进行规格化处理时只存在向左规格化，不可能出现向右规格化。
4. 判断溢出: 浮点数乘除运算结果的尾数不可能发生溢出，而浮点数运算结果的溢出则根据运算结果中浮点数的阶码来确定，溢出的判定和处理方法与浮点加减运算完全相同。

## 算法流程
1. unpack: 消耗一个时钟周期。
2. 阶码相减、尾数相除、舍入处理: 消耗两个时钟周期。
3. 结果规格化: 消耗一个时钟周期。
4. 判断溢出、各项合并: 采用组合逻辑。

# 浮点数幂指数运算

## 算法理解

浮点数的标准表示如下：

    Y = (-1)^S * (1+M) * 2^X,X = E - bias

假设S = 0,M = 0,则Y = 2^X = 2^(E - bias)。如果想要计算2^X,只需要将(X+bias)放到浮点数内存中E所在的位置即可。以单精度浮点数为例，只需要将(X+bias)左移23位。所以有：

    2^X = 2^offset * (X+bias)

由于$2^X=e^{\ln2^X}$,令$\ln2^X = T$,则$X * \ln2 = T$, $X = T/\ln2$,所以有: $e^T = 2^X = 2^{T/\ln2} = 2^{offset} * (T/\ln2 + bias)$,这样就能将exp转化为2的指数幂进行运算了。

## 算法实操

1. 将输入的浮点数转化为定点小数。
2. 对定点小数进行量化操作。
3. 通过定点数乘法和加法得到浮点数。

### 量化操作

设 X = a + b,输入的浮点数经转化后得到定点小数A, cofficient = 1.4427,constant = 14.9427,offset = 2^10 = 1024

首先对A、cofficient、constant进行量化的操作;

理论值为: y = (A * cofficient + constant) * offset

实际值为: w = (A * 2^a + cofficient * 2^b + constant * 2^X) * offset
    
           = (A * cofficient + constant) * offset * 2^X

         y = w/2^X























